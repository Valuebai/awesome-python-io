### 目录结构
- **1.封装**
- 2.面向对象之paivate关键字
- 3.面向对象之this关键字
- 4.面向对象之构造方法
- **5.创建对象的步骤**
- 6.面向对象之static关键字的特点
- 7.静态变量和成员变量的区别
- 8.代码块
- **9.继承**
- 10.this和super的区别
- 11.方法重写，方法重载
- 12.final关键字概述
- **13.多态**
- 14.多态的弊端和好处





#### 1.封装
- **1.1 封装的概述**
- 封装概述
	* 是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。
- 封装好处
	* 隐藏实现细节，提供公共的访问方式
	* 提高代码复用性
	* 提高安全性[禁止对象之间的不良交互提高模块化]
- 封装原则
	* 将不需要对外提供的内容都隐藏起来。
	* 把属性隐藏，提供公共方法对其访问。
- 案例展示
    - 以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。
    - 注意到gender属性使用int数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。
        ```
        public class Person {
        
            private String name;
            private int gender;
            private int age;
        
            public String getName() {
                return name;
            }
        
            public String getGender() {
                return gender == 0 ? "man" : "woman";
            }
        
            public void work() {
                if (18 <= age && age <= 50) {
                    System.out.println(name + " is working very hard!");
                } else {
                    System.out.println(name + " can't work any more!");
                }
            }
        }
        ```


#### 2.面向对象之paivate关键字
- private关键字特点
	* 是一个权限修饰符
	* 可以修饰成员变量和成员方法
	* 被其修饰的成员只能在本类中被访问
- private最常见的应用
	* 把成员变量用private修饰，提供对应的getXxx()和setXxx()方法



#### 3.面向对象之this关键字
- 为什么要有this
	* 当我们的局部变量和成员变量相同的时候,如果我们不使用this关键字,那么会导致一个问题:就是局部变量隐藏了成员变量的问题
- this关键字特点
	* 是当前类的对象引用
	* 简单的记，它就代表当前类的一个对象。谁调用这个方法,那么该方法的内部的this就代表谁
- this的应用场景
	* 解决局部变量隐藏成员变量



#### 4.面向对象之构造方法
- 构造方法概述和作用
	* 给对象中的成员进行初始化
- 构造方法格式特点
	* 方法名与类名相同；没有返回值类型，连void都没有
- 构造方法注意事项
	* 如果我们没有给出构造方法，系统将自动提供一个无参构造方法。
	* 如果我们给出了构造方法，系统将不再提供默认的无参构造方法。
		* 注意：这个时候，如果我们还想使用无参构造方法，就必须自己给出。建议永远自己给出无参构造方法




#### 5.创建对象的步骤
- 对象的创建步骤
	* (1):加载A.class文件进内存
	* (2):在栈内存为s开辟空间
	* (3):在堆内存为学生对象开辟空间
	* (4):对学生对象的成员变量进行默认初始化
	* (5):对学生对象的成员变量进行显示初始化
	* (6):通过构造方法对学生对象的成员变量赋值
	* (7):学生对象初始化完毕，把对象地址赋值给s变量



#### 6.面向对象之static关键字的特点
- **6.1 static关键字的特点**
	* 随着类的加载而加载
	* 优先于对象存在
	* 被类的所有对象共享
	* 可以通过类名调用【静态修饰的内容一般我们称其为：与类相关的，类成员】
- **6.2 static的注意事项**
	* 在静态方法中是没有this关键字的
		* 静态是随着类的加载而加载，this是随着对象的创建而存在。
		* 静态比对象先存在。
	* 静态方法只能访问静态的成员变量和静态的成员方法【静态只能访问静态,非静态可以访问静态的也可以访问非静态的】



#### 7.静态变量和成员变量的区别
- A:所属不同
	* 静态变量属于类，所以也称为类变量
	* 成员变量属于对象，所以也称为实例变量(对象变量)
- B:内存中位置不同
	* 静态变量存储于方法区的静态区
	* 成员变量存储于堆内存
- C:内存出现时间不同
	* 静态变量随着类的加载而加载，随着类的消失而消失
	* 成员变量随着对象的创建而存在，随着对象的消失而消失
- D:调用不同
	* 静态变量可以通过类名调用，也可以通过对象调用
	* 成员变量只能通过对象名调用



#### 8.代码块
- A:代码块概述
	* 在Java中，使用{}括起来的代码被称为代码块。
- B:代码块分类
	* 根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块。
- C:常见代码块的应用
    * a:局部代码块
		* 在方法中出现；限定变量生命周期，及早释放，提高内存利用率
    * b:构造代码块
		* 在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行
    * c:静态代码块
		* 在类中方法外出现，加了static修饰
		* 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。



#### 9.继承
- **9.1 继承概述**
	* 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。
- **9.2 继承格式**
	* 通过extends关键字可以实现类与类的继承
	* class 子类名 extends 父类名 {} 
	* 单独的这个类称为父类，基类或者超类；这多个类可以称为子类或者派生类
- **9.3 继承的好处**
	* a:提高了代码的复用性
	* b:提高了代码的维护性
	* c:让类与类之间产生了关系，是多态的前提
- **9.4 继承的弊端**
	* 类的耦合性增强了。
	* 开发的原则：高内聚，低耦合。
	* 耦合：类与类的关系
	* 内聚：就是自己完成某件事情的能力
- **9.5 继承的注意事项**
	* a:子类只能继承父类所有非私有的成员(成员方法和成员变量)
	* b:子类不能继承父类的构造方法，但是可以通过super(待会儿讲)关键字去访问父类构造方法。
	* c:不要为了部分功能而去继承
- **9.6 继承中成员变量的关系**
	* A:子类中的成员变量和父类中的成员变量名称不一样
	* B:子类中的成员变量和父类中的成员变量名称一样
	* 在子类中访问一个变量的查找顺序("就近原则")
		* a: 在子类的方法的局部范围找,有就使用
		* b: 在子类的成员范围找,有就使用
		* c: 在父类的成员范围找,有就使用
			* d:如果还找不到,就报错
- **9.7 继承中构造方法的注意事项**
	* 父类没有无参构造方法,子类怎么办?
		* a: 在父类中添加一个无参的构造方法
		* b:子类通过super去显示调用父类其他的带参的构造方法
		* c:子类通过this去调用本类的其他构造方法
		* 本类其他构造也必须首先访问了父类构造
	* B:注意事项
	    * super(…)或者this(….)必须出现在第一条语句上



#### 10.this和super的区别
- **A:通过问题引出super**
	* 子类局部范围访问父类成员变量
- **B:说说this和super的区别**
	* this     代表的是本类对象的引用
	* super     代表的是父类存储空间的标识(可以理解成父类的引用,可以操作父类的成员)
- **C:this和super的使用**
	* a:调用成员变量
		* this.成员变量     调用本类的成员变量
		* super.成员变量     调用父类的成员变量
	* b:调用构造方法
		* this(...)        调用本类的构造方法
		* super(...)        调用父类的构造方法
	* c:调用成员方法
		* this.成员方法     调用本类的成员方法
		* super.成员方法     调用父类的成员方法



#### 11.方法重写，方法重载
- **11.1 方法重写**
- **A:什么是方法重写**
	* 子类中出现了和父类中一模一样的方法声明(方法名,参数列表,返回值类型)，也被称为方法覆盖，方法复写。
- B: Override和Overload的区别?Overload能改变返回值类型吗?
- **C:方法重写的应用**
	* 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。
	* 这样，即沿袭了父类的功能，又定义了子类特有的内容。
- **方法重写注意事项**
	* a:父类中私有方法不能被重写 ，因为父类私有方法子类根本就无法继承
	* b:子类重写父类方法时，访问权限不能更低 ，最好就一致
	* c:父类静态方法，子类也必须通过静态方法进行重写 ，其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中我会讲解


- **11.2 方法重载**
- A.什么是方法重载？
- 一个类中，有若干个方法名字相同，但方法参数形式不同，成为方法重载
- B.方法重载原则？
- 方法名相同；方法的参数类型不同，或者参数个数不同；与方法的参数名，返回类型和修饰符无关


#### 12.final关键字概述
- **A:为什么会有final**
	* 由于继承中有一个方法重写的现象,而有时候我们不想让子类去重写父类的方法.这对这种情况java就给我们提供了一个关键字: final
- **B:final概述**
	* final关键字是最终的意思，可以修饰类，变量，成员方法。
- **C:final修饰特点**
	* 修饰类:    被修饰类不能被继承
	* 修饰方法:    被修饰的方法不能被重写
	* 修饰变量:    被修饰的变量不能被重新赋值,因为这个量其实是一个常量
- **D:final关键字修饰局部变量 **     
	* 基本类型，是值不能被改变
	* 引用类型，是地址值不能被改变

















### 关于其他内容介绍
#### 01.关于博客汇总链接
- 1.[技术博客汇总](https://www.jianshu.com/p/614cb839182c)
- 2.[开源项目汇总](https://blog.csdn.net/m0_37700275/article/details/80863574)
- 3.[生活博客汇总](https://blog.csdn.net/m0_37700275/article/details/79832978)
- 4.[喜马拉雅音频汇总](https://www.jianshu.com/p/f665de16d1eb)
- 5.[其他汇总](https://www.jianshu.com/p/53017c3fc75d)



#### 02.关于我的博客
- 我的个人站点：www.yczbj.org，www.ycbjie.cn
- github：https://github.com/yangchong211
- 知乎：https://www.zhihu.com/people/yang-chong-69-24/pins/posts
- 简书：http://www.jianshu.com/u/b7b2c6ed9284
- csdn：http://my.csdn.net/m0_37700275
- 喜马拉雅听书：http://www.ximalaya.com/zhubo/71989305/
- 开源中国：https://my.oschina.net/zbj1618/blog
- 泡在网上的日子：http://www.jcodecraeer.com/member/content_list.php?channelid=1
- 邮箱：yangchong211@163.com
- 阿里云博客：https://yq.aliyun.com/users/article?spm=5176.100- 239.headeruserinfo.3.dT4bcV
- segmentfault头条：https://segmentfault.com/u/xiangjianyu/articles
